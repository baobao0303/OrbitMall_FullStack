{"version":3,"file":"view-base.mjs","sources":["../../../../projects/view/base/src/lib/view.active.ts","../../../../projects/view/base/src/lib/view.active.registry.ts","../../../../projects/view/base/src/lib/view.aggregation.context.ts","../../../../projects/view/base/src/lib/view.command.mediator.ts","../../../../projects/view/base/src/lib/view.command.registry.ts","../../../../projects/view/base/src/lib/view.command.helper.ts","../../../../projects/view/base/src/lib/view.base.ts","../../../../projects/view/base/src/lib/view.render.registry.ts","../../../../projects/view/base/src/lib/view.command.base.ts","../../../../projects/view/base/src/lib/view.context.ts","../../../../projects/view/base/src/lib/view.edit.context.ts","../../../../projects/view/base/src/lib/view.list.context.ts","../../../../projects/view/base/src/lib/view.ref.mapper.registry.ts","../../../../projects/view/base/src/public-api.ts","../../../../projects/view/base/src/view-base.ts"],"sourcesContent":["import { computed, Injectable, InjectionToken, signal } from '@angular/core';\nimport { ViewData } from './view.type';\nimport { ViewActiveRegistry } from './view.active.registry';\n\n/**\n * At the once time, the class will keep the active component (view)\n * Support to identify the view to handle the keyboard push or others\n */\n@Injectable({ providedIn: 'root' })\nexport class ViewActive implements ViewActiveRegistry {\n  /**\n   * ActiveView signal will store the actve view (only one)\n   * Sync with signal\n   * The variable is different to compare with Active window in Hub (Window)\n   */\n  private _activeView = signal('');\n  private _activeViewData = signal<ViewData>({});\n\n  /**\n   * Return the current active view\n   * Sync with signal\n   */\n  public getActiveView = computed(() => this._activeView());\n\n  /**\n   * Return the current active view data\n   */\n  public getActiveViewData = computed(() => this._activeViewData());\n\n  /**\n   * Set active view\n   * @param activeView {string}\n   * @param activeViewData {ViewData}\n   */\n  public setActiveView(activeView: string, activeViewData?: ViewData): void {\n    this._activeView.set(activeView);\n    /** Store data into as state or anything */\n    if (activeViewData) this._activeViewData.set(activeViewData);\n  }\n\n  /**\n   * Set active view data\n   * @param activeView {string}\n   * @param activeViewData {ViewData}\n   */\n  public setActiveViewData(activeView: string, activeViewData?: ViewData) {\n    if (activeView == this._activeView()) {\n      if (activeViewData != undefined) {\n        const newViewData = { ...this._activeViewData(), ...activeViewData };\n        this._activeViewData.set(newViewData);\n      }\n    }\n  }\n}\n","import { InjectionToken } from '@angular/core';\nimport { ViewData } from './view.type';\n\nexport interface ViewActiveRegistry {\n  getActiveView(): string;\n  getActiveViewData(): ViewData;\n  setActiveView(activeView: string, data?: ViewData): void;\n  setActiveViewData(activeView: string, activeViewData?: ViewData): void;\n}\n\nexport const VIEW_ACTIVE_REGISTRY = new InjectionToken<ViewActiveRegistry>('VIEW_ACTIVE_REGISTRY');\n","import { InjectionToken } from '@angular/core';\nimport { ViewEditContext } from './view.edit.context';\nimport { ViewListContext } from './view.list.context';\n\n/**\n * Aggregate all context for use\n */\nexport interface ViewAggregationContext extends ViewListContext, ViewEditContext {}\nexport const VIEW_CONTEXT = new InjectionToken<ViewAggregationContext>('VIEW_CONTEXT');\n","import { Injectable } from '@angular/core';\nimport { ViewCommand } from './view.command';\nimport { ViewData } from './view.type';\n\nexport type ViewCommandType = {\n  /**\n   * View Name for the command\n   */\n  viewName: string;\n\n  /**\n   * View Command to execute\n   */\n  viewCommand: ViewCommand;\n\n  /**\n   * If true, it will be registered as shortcut\n   */\n  isShortcutRegister: boolean;\n\n  /**\n   * This is permanent command, it will not be removed\n   */\n  isPermanent: boolean;\n\n  /**\n   * To remove listener for dispose the command\n   */\n  toRemoveListener: any;\n};\n\n/**\n * Keyboard keys\n */\nexport enum KeyboardKeys {\n  Control = 'control',\n  Alt = 'alt',\n  Shift = 'shift',\n  Escape = 'escape',\n}\n\n/**\n * Key Map for the keyboard keys\n */\nexport const KEY_MAP = {\n  '\\b': 'Backspace',\n  '\\t': 'Tab',\n  '\\x7F': 'Delete',\n  '\\x1B': 'Escape',\n  Del: 'Delete',\n  Esc: 'Escape',\n  Left: 'ArrowLeft',\n  Right: 'ArrowRight',\n  Up: 'ArrowUp',\n  Down: 'ArrowDown',\n  Menu: 'ContextMenu',\n  Scroll: 'ScrollLock',\n  Win: 'OS',\n};\n\n/**\n * Modifier key getters\n */\nexport const MODIFIER_KEY_GETTERS: { [key: string]: (event: KeyboardEvent) => boolean } = {\n  alt: (event: KeyboardEvent) => event.altKey,\n  control: (event: KeyboardEvent) => event.ctrlKey,\n  meta: (event: KeyboardEvent) => event.metaKey,\n  shift: (event: KeyboardEvent) => event.shiftKey,\n  break: () => false,\n};\n\n/**\n * View Command Map to store all view commands, it will be used to execute command by key\n *\n * @example\n *  'keydown.ctrl.s' -> [\n *   {\n *      viewName: 'view1',\n *      viewCommand: { execute: () => { console.log('view1') } },\n *      isShortcutRegister: true,\n *      isPermanent: false,\n *      toRemoveListener: undefined\n *  },\n *  {\n *     viewName: 'view2',\n *     viewCommand: { execute: () => { console.log('view2') } },\n *     isShortcutRegister: true,\n *     isPermanent: false,\n *     toRemoveListener: undefined\n *  }\n * ]\n *\n */\nexport type ViewCommandMap = Map<string, ViewCommandType[]>;\n\n@Injectable({ providedIn: 'root' })\nexport class ViewCommandMediator {\n  private readonly _viewCommandMap: ViewCommandMap = new Map<string, ViewCommandType[]>();\n\n  /**\n   * Set view command to the map\n   *\n   * @param key [string] -> e.g. 'keydown.control.s'\n   * @param viewName [string] -> view name for the command, eg: 'ViewConstant.CONTACT' -> 'contact'\n   * @param viewCommand [ViewCommand] -> ViewCommand to execute, eg: { execute: () => { console.log('view1') } }\n   * @param isShortcutRegister [boolean] -> If true, it will be registered as shortcut\n   * @param isPermanent [boolean] -> If true, it will be permanent command, it will not be removed\n   */\n  public setViewCommandToMap(key: string, viewName: string, viewCommand: ViewCommand, isShortcutRegister: boolean = false, isPermanent: boolean = false) {\n    // Get the command with key from the map, It can be multiple commands with same key\n    const command: ViewCommandType[] | undefined = this._viewCommandMap.get(key);\n\n    const viewCommandType: ViewCommandType = {\n      viewName: viewName,\n      viewCommand: viewCommand,\n      isShortcutRegister: isShortcutRegister,\n      isPermanent: isPermanent,\n      toRemoveListener: undefined,\n    };\n\n    if (!command) {\n      // If command not found, then create new command and add to the map\n      this._viewCommandMap.set(key, [viewCommandType]);\n    } else {\n      // If command found, then add new command to the list\n      command.push(viewCommandType);\n    }\n\n    // console.info(`[ViewCommandMediator.setViewCommandToMap] Command '${key}' adding new command to the list ...`, this._viewCommandMap.get(key));\n    // console.info(`[ViewCommandMediator.setViewCommandToMap] Command '${key}' Total command: `);\n    // console.table(Array.from(this._viewCommandMap.entries(), ([k, v]) => ({ key: k, value: { v } })));\n  }\n\n  /**\n   * Execute command by key\n   * @param key   -> string: key string. e.g. 'keydown.ctrl.s'\n   * @param data  -> data, it can any in json or undefined to pass to the command\n   * @param viewName -> view name to execute the command. If viewName is provided, then execute only that command otherwise execute all commands with key\n   */\n  public executeCommandFromMap(key: string, data?: ViewData, viewName?: string) {\n    // console.log('DEBUG: executeCommandFromMap', key, data, viewName);\n    const commands: ViewCommandType[] | undefined = this._viewCommandMap.get(key);\n\n    if (!commands) {\n      console.warn(`[ViewCommandMediator.executeCommandFromMap] Command '${key}' not found to execute ...`);\n      return;\n    }\n\n    // If viewName is provided, then execute only that command\n    if (viewName) {\n      const command: ViewCommandType | undefined = this.getViewCommand(key, viewName);\n      if (!command) {\n        console.warn(`[ViewCommandMediator.executeCommandFromMap] Command '${key}' not found to execute`);\n        return;\n      }\n      command.viewCommand.executeCommand(data);\n      console.info(`[ViewCommandMediator.executeCommandFromMap] Command '${key}' executed ...`, data, viewName);\n    } else {\n      // Execute all commands with key\n      // TODO: this's never be called\n      commands.forEach((command: ViewCommandType) => {\n        command.viewCommand.executeCommand(data);\n      });\n    }\n  }\n\n  /**\n   * Get all commands with key\n   * @param key string\n   * @returns ViewCommandType[] | undefined\n   */\n  public getViewCommands = (key: string) => this._viewCommandMap.get(key);\n\n  /**\n   * Get command with key and viewName\n   * @param key string\n   * @param viewName string\n   * @returns ViewCommandType | undefined\n   */\n  public getViewCommand = (key: string, viewName: string) => {\n    const commands: ViewCommandType[] | undefined = this._viewCommandMap.get(key);\n\n    if (!commands) {\n      console.warn(`[ViewCommandMediator.getViewCommand] Command '${key}' not found to execute ...`);\n      return;\n    }\n\n    return commands.find((command) => command.viewName === viewName);\n  };\n\n  /**\n   * Delete all commands with key\n   * @warning This will delete all commands with key\n   * @param key\n   */\n  public deleteCommands = (key: string) => this._viewCommandMap.delete(key);\n\n  /**\n   * Delete command with key and viewName\n   * @param key\n   * @param viewName\n   */\n  public deleteCommand(key: string, viewName: string) {\n    const commands: ViewCommandType[] | undefined = this._viewCommandMap.get(key);\n\n    if (!commands) {\n      console.log(`[ViewCommandMediator.deleteCommand] Command '${key}' not found to delete ...`);\n      return;\n    }\n\n    const index = commands.findIndex((command) => command.viewName === viewName);\n\n    if (index !== -1) {\n      commands.splice(index, 1);\n    }\n\n    // If no command found, then delete the key from the map\n    if (commands.length === 0) {\n      this._viewCommandMap.delete(key);\n    }\n\n    // console.info(`[ViewCommandMediator.deleteCommand] Command remaining '${key}'`, this._viewCommandMap.get(key));\n\n    return;\n  }\n\n  /**\n   * Get all view commands by property\n   * @param propertyKey - The property to filter by (e.g., 'isShortcutRegister' or 'isPermanent')\n   * @param propertyValue - The value of the property to match\n   * @see {@link ViewCommandMap} - A map of view commands that match the property\n   */\n  public getViewCommandsByProperty<T extends keyof ViewCommandType>(propertyKey: T, propertyValue: ViewCommandType[T]) {\n    const viewCommands: ViewCommandMap = new Map<string, ViewCommandType[]>();\n\n    this._viewCommandMap.forEach((commands: ViewCommandType[], key: string) => {\n      let commandsHasKey: ViewCommandType[] = [];\n      Array.from(commands).forEach((command) => {\n        if (command[propertyKey] === propertyValue) {\n          commandsHasKey.push(command);\n        }\n      });\n      viewCommands.set(key, commandsHasKey);\n    });\n\n    return viewCommands;\n  }\n\n  public get size() {\n    return this._viewCommandMap.size;\n  }\n\n  /**\n   * Handle keydown event\n   * @param event - KeyboardEvent\n   * @param data - ViewData\n   * @param viewName - string e.g. 'hub_component'\n   * @returns\n   */\n  public onKeydownEventHandler(event: KeyboardEvent, data?: ViewData, viewName?: string) {\n    event.preventDefault();\n\n    // Get the key code\n    let keycode = KEY_MAP[event.key as keyof typeof KEY_MAP] || event.key;\n\n    var keyCombining = '';\n    if (keycode == null || keycode == undefined) {\n      console.warn(`[ViewCommandMediator.onKeydownEventHandler] keyCode is null or undefined ...`);\n      return false;\n    }\n    keycode.toLowerCase();\n    if (keycode === ' ') {\n      // For space key\n      // @example 'keydown.space'\n      keycode = 'space';\n    } else if (keycode === '.') {\n      // For dot key\n      // @example 'keydown.ctrl.'\n      keycode = 'dot';\n    }\n\n    Array.from(Object.keys(KeyboardKeys)).forEach((modifierKey: string, idx) => {\n      modifierKey = modifierKey.toLowerCase();\n\n      if (modifierKey !== keycode) {\n        const modifierKeyGetter = MODIFIER_KEY_GETTERS[modifierKey] || MODIFIER_KEY_GETTERS['break'];\n\n        if (modifierKeyGetter(event) !== undefined && modifierKeyGetter(event)) {\n          keyCombining += `${modifierKey}.`;\n        }\n      }\n    });\n\n    keyCombining += keycode;\n    return this.executeCommandFromMap(`keydown.${keyCombining}`, data, viewName);\n  }\n}\n","import { InjectionToken } from '@angular/core';\n\nexport interface ViewCommandRegistry {\n  commandRegister(): void;\n  viewName(): string;\n}\nexport const VIEW_COMMAND_REGISTRY = new InjectionToken<ViewCommandRegistry>('VIEW_COMMAND_REGISTRY');\n\nexport interface ViewCommandMapperRegistry {\n  getKeyViewCommand(name: string): string;\n}\n\nexport const VIEW_COMMAND_MAPPER_REGISTRY = new InjectionToken<ViewCommandMapperRegistry>('VIEW_COMMAND_MAPPER_REGISTRY');\n","import { effect, inject, Signal, signal } from '@angular/core';\nimport { ViewCommand } from './view.command';\nimport { ViewCommandMediator } from './view.command.mediator';\n\nimport { ViewData } from './view.type';\nimport { VIEW_COMMAND_MAPPER_REGISTRY, VIEW_COMMAND_REGISTRY } from './view.command.registry';\n\n/**\n * Native key (shortcut) as command register.\n * It must be used in runInInjectionContext\n * @param key - shortcut key (e.g. 'ctrl+shift+1')\n * @param viewCommand - command to be executed\n * @param isShortcutRegister - is it a shortcut register\n * @param isPermanent - is it a permanent register\n */\nexport function nativeCommandRegister(key: string, viewCommand: ViewCommand, isShortcutRegister: boolean = false, isPermanent: boolean = false) {\n  const _viewCommandMediator = inject(ViewCommandMediator);\n  const _viewCommandMapperRegistry = inject(VIEW_COMMAND_MAPPER_REGISTRY);\n  const _viewCommandRegistry = inject(VIEW_COMMAND_REGISTRY);\n\n  _viewCommandMediator.setViewCommandToMap(_viewCommandMapperRegistry.getKeyViewCommand(key), _viewCommandRegistry.viewName(), viewCommand, isShortcutRegister, isPermanent);\n}\n\n/**\n * Native key (shortcut) as command register.\n * With permanent\n * @param key\n * @param viewCommand\n */\nexport function nativeCommandWithPermanentRegister(key: string, viewCommand: ViewCommand) {\n  nativeCommandRegister(key, viewCommand, false, true);\n}\n\n/**\n * Native key (shortcut) as command register.\n * Without permanent\n * @param key\n * @param viewCommand\n */\nexport function nativeCommandWithoutPermanentRegister(key: string, viewCommand: ViewCommand) {\n  nativeCommandRegister(key, viewCommand, false, false);\n}\n\n/**\n * Execute commands from everywhere.\n * @warning It must be used in runInInjectionContext\n * @see {@link https://angular.dev/api/core/runInInjectionContext?tab=api}\n * @param key - shortcut key (e.g. 'ctrl+shift+1')\n * @param data - view data {@link ViewData}\n * @param viewName - view name (e.g. 'hub_component')\n */\nexport function executeShortcutCommand(key: string, data?: ViewData, viewName?: string) {\n  const _viewCommandMediator = inject(ViewCommandMediator);\n\n  _viewCommandMediator.executeCommandFromMap(key, data, viewName);\n}\n\n/**\n * Creates a debounced signal that updates its value after a specified delay.\n *\n * @template T - The type of the signal value.\n * @param {Signal<T>} sourceSignal - The reference to the original signal.\n * @param {number} [debounceTimeInMs=0] - The delay in milliseconds before the signal updates.\n * @returns {Signal<T>} - A new signal that updates its value after the specified delay.\n */\nexport function debouncedSignal<T>(sourceSignal: Signal<T>, debounceTimeInMs: number = 0): Signal<T> {\n  const debounceSignal = signal(sourceSignal());\n  effect(\n    (onCleanup) => {\n      const value = sourceSignal();\n      const timeout = setTimeout(() => debounceSignal.set(value), debounceTimeInMs);\n\n      // The `onCleanup` argument is a function which is called when the effect\n      // runs again (and when it is destroyed).\n      // By clearing the timeout here we achieve proper debouncing.\n      // See https://angular.io/guide/signals#effect-cleanup-functions\n      onCleanup(() => clearTimeout(timeout));\n    },\n    { allowSignalWrites: true },\n  );\n  return debounceSignal;\n}\n","import { Dialog, DialogRef } from '@angular/cdk/dialog';\nimport { Overlay } from '@angular/cdk/overlay';\nimport { DOCUMENT } from '@angular/common';\nimport { computed, inject, Injector, Renderer2, runInInjectionContext, signal, Type } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { BROWSER_STORAGE } from '@infrastructure/base';\nimport { ActionHandlerType, ViewData, ViewMode } from './view.type';\nimport { ViewRenderRegistry } from './view.render.registry';\nimport { ViewCommandMediator } from './view.command.mediator';\nimport { VIEW_CONTEXT } from './view.aggregation.context';\nimport { VIEW_COMMAND_MAPPER_REGISTRY } from './view.command.registry';\nimport { ViewContext } from './view.context';\nimport { executeShortcutCommand } from './view.command.helper';\nimport { ViewOptions } from './view.options';\n\nexport abstract class ViewBase {\n  protected readonly _injector = inject(Injector);\n  protected readonly _vcm = inject(ViewCommandMediator);\n  protected readonly _router = inject(Router);\n  protected readonly _renderer = inject(Renderer2);\n  protected readonly _dialog = inject(Dialog);\n  protected readonly _overlay = inject(Overlay);\n  protected readonly _document = inject(DOCUMENT);\n  protected readonly _storage = inject(BROWSER_STORAGE);\n  protected readonly _context = inject(VIEW_CONTEXT);\n  protected readonly _viewCommandMapperRegistry = inject(VIEW_COMMAND_MAPPER_REGISTRY);\n\n  /**\n   * TODO: MOVE THIS TO VIEW CONTEXT\n   * A signal representing the current view mode of the widget.\n   *\n   * @protected\n   * @default 'VIEW'\n   */\n  protected _viewMode = signal<ViewMode>('VIEW');\n  public setViewMode(viewMode: ViewMode) {\n    this._viewMode.set(viewMode);\n  }\n  public getViewMode = computed(() => this._viewMode());\n\n  /**\n   * Open dialog with options\n   * @param {DialogOptions} options\n   * @param {Type<ViewRenderRegistry>} componentType\n   */\n  public openDialog<T extends ViewOptions>(componentType: Type<ViewRenderRegistry>, options?: T) {\n    const dialogConfig = {\n      data: options,\n      disableClose: options?.disableClose ?? true,\n      autoFocus: true,\n      hasBackdrop: true,\n      restoreFocus: true,\n      width: options ? undefined : '530px',\n    };\n\n    let dialogRef: DialogRef<unknown, ViewRenderRegistry> | DialogRef<unknown> | null = null;\n\n    if (componentType) {\n      dialogRef = this._dialog.open(componentType, dialogConfig);\n      dialogRef.closed.subscribe((result) => {\n        if (options?.actionHandler) {\n          const actionResult = result as ActionHandlerType;\n          options.actionHandler(actionResult);\n        }\n      });\n    }\n  }\n\n  /**\n   * Executes a command based on the provided key, optional data, and optional view name.\n   *\n   * @param key - The key representing the command to be executed.\n   * @param data - Optional data to be passed to the command.\n   * @param viewName - Optional name of the view where the command is executed.\n   */\n  public executeCommand(key: string, data?: ViewData, viewName?: string) {\n    const shortCutKey = this._viewCommandMapperRegistry.getKeyViewCommand(key);\n    runInInjectionContext(this._injector, () => {\n      executeShortcutCommand(shortCutKey, data, viewName);\n    });\n  }\n\n  /**\n   * Retrieves the current context and casts it to the specified type.\n   *\n   * @template CType - The type to cast the context to, which extends `ViewContext`.\n   * @returns The current context cast to the specified type `CType`.\n   */\n  public getContextAs<CType extends ViewContext>(): CType {\n    const context = this._context as unknown;\n    return context as CType;\n  }\n}\n","import { InjectionToken, Type } from '@angular/core';\nimport { ViewData, ViewDataType, ViewMode } from './view.type';\n\n/**\n * Defines interface ViewAction\n * To use in Widget / Component (write own Button, Input, Dropdow, ...)\n */\nexport interface ViewAction {\n  setTabIndex(value: number): void;\n  setFocused(focused: boolean): void;\n  setDisabled(disabled: boolean): void;\n}\nexport const VIEW_ACTION = new InjectionToken<ViewAction>('VIEW_ACTION');\n\n/**\n * Defines interface ViewRenderRegistry\n * To set the view name (vid) and view type (component)\n */\nexport interface ViewRenderRegistry {\n  viewName(): string; // name to register\n  viewType(): Type<ViewRenderRegistry>; // type = CalendarComponent, type = ContactComponent\n}\n\n/**\n * Defines interface ViewRenderActionRegistry\n * To set reload function\n */\nexport interface ViewRenderActionRegistry extends ViewAction, ViewRenderRegistry {\n  viewReload(filter?: ViewDataType): void;\n  setViewMode(viewMode: ViewMode): void;\n  getViewMode(): ViewMode;\n  actionHandler(actionType: string, data?: ViewData): void;\n}\n\nexport const VIEW_RENDER_REGISTRY = new InjectionToken<ViewRenderActionRegistry>('VIEW_RENDER_REGISTRY');\n","import { inject } from '@angular/core';\nimport { ViewContext } from './view.context';\nimport { VIEW_RENDER_REGISTRY } from './view.render.registry';\nimport { ViewCommand } from './view.command';\nimport { VIEW_CONTEXT } from './view.aggregation.context';\nimport { ViewData } from './view.type';\nimport { VIEW_ACTIVE_REGISTRY } from './view.active.registry';\n\nexport abstract class ViewCommandBase implements ViewCommand {\n  protected readonly _context = inject(VIEW_CONTEXT);\n  protected readonly _viewRenderRegistry = inject(VIEW_RENDER_REGISTRY);\n  protected readonly _viewActiveRegistry = inject(VIEW_ACTIVE_REGISTRY);\n  private _viewActiveChecked = false;\n\n  /**\n   * Defines this method as get the context type for type check\n   * @returns Context Type\n   */\n  public getContextAs<CType extends ViewContext>(): CType {\n    const context = this._context as unknown;\n    return context as CType;\n  }\n\n  public viewActiveChecked(viewActiveCheck: boolean = true) {\n    this._viewActiveChecked = viewActiveCheck;\n  }\n\n  /**\n   * Execute the command with data and viewName\n   * @param data - data to pass to the command\n   * @param viewName - view name to execute the command e.g 'hub', 'contact', 'product_list'\n   */\n  protected abstract execute(data?: ViewData, viewName?: string): void;\n\n  public executeCommand(data?: ViewData) {\n    const viewName = this._viewRenderRegistry.viewName();\n\n    if (this._viewActiveChecked) {\n      if (viewName == this._viewActiveRegistry.getActiveView()) {\n        console.log(`Execute command in View=[${viewName}] with MeViewActive=${this._viewActiveChecked}`);\n        this.execute(data);\n      }\n    } else {\n      this.execute(data);\n    }\n  }\n}\n","import { Overlay, OverlayConfig, OverlayRef } from '@angular/cdk/overlay';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { ComponentRef, computed, inject, Signal, signal } from '@angular/core';\nimport { MatProgressSpinner } from '@angular/material/progress-spinner';\nimport { AuthorizationConstant } from '@infrastructure/authorization';\nimport { BROWSER_STORAGE } from '@infrastructure/base';\nimport { catchError, finalize, Observable, tap } from 'rxjs';\nimport { ViewDataType, ViewState } from './view.type';\n\n/**\n * The `ViewContext` abstract class provides a base implementation for managing the state of a view,\n * handling requests with error management, and displaying a loading overlay during asynchronous operations.\n *\n * @abstract\n * @class\n */\nexport abstract class ViewContext {\n  protected readonly storage = inject(BROWSER_STORAGE);\n  private readonly overlay = inject(Overlay);\n  private overlayRef: OverlayRef | null = null;\n  /**\n   * A protected property that holds the current state of the view.\n   * It uses a signal to manage the state, which is initially set to 'INIT'.\n   *\n   * @protected\n   * @default 'INIT'\n   */\n  protected _viewState = signal<ViewState>('INIT');\n  public setViewState(viewState: ViewState) {\n    this._viewState.set(viewState);\n  }\n  public getViewState = computed(() => this._viewState());\n\n  public get isInit(): Signal<boolean> {\n    return computed(() => this.getViewState() === 'INIT');\n  }\n\n  public get isIdle(): Signal<boolean> {\n    return computed(() => this.getViewState() === 'IDLE');\n  }\n\n  public get isLoading(): Signal<boolean> {\n    return computed(() => this.getViewState() === 'LOADING');\n  }\n\n  public get isLoaded(): Signal<boolean> {\n    return computed(() => this.getViewState() === 'LOADED');\n  }\n\n  public get isError(): Signal<boolean> {\n    return computed(() => this.getViewState() === 'ERROR');\n  }\n\n  /**\n   * Wraps the provided request function with error handling logic.\n   *\n   * @param request - The request function to be wrapped.\n   * @param onError - Optional error handler to be executed when an error occurs.\n   */\n  protected executeRequest<T>(request: Observable<T>): Observable<T> {\n    this.setViewState('LOADING');\n\n    return request.pipe(\n      tap(() => this.setViewState('LOADED')),\n      catchError((error) => {\n        this.setViewState('ERROR');\n        throw error;\n      }),\n      finalize(() => this.setViewState('IDLE')),\n    );\n  }\n\n  /**\n   * Executes a given request while displaying a loading overlay.\n   *\n   * This method opens a loading overlay before executing the request and ensures\n   * that the overlay is closed once the request is finalized, regardless of whether\n   * it succeeds or fails.\n   *\n   * @template T - The type of the response expected from the request.\n   * @param {Observable<T>} request - The observable request to be executed.\n   * @returns {Observable<T>} - An observable that emits the response of the request.\n   */\n  protected executeRequestWithLoadingOverlay<T>(request: Observable<T>): Observable<T> {\n    this.openLoadingOverlay();\n\n    return this.executeRequest(request).pipe(finalize(() => this.closeOverlay()));\n  }\n\n  /**\n   * Executes a request while displaying a loading overlay and handling an event.\n   *\n   * This method opens a loading overlay, executes the given request, and then\n   * subscribes to the provided event to close the overlay. The overlay is closed\n   * both when the event is emitted and when the request completes.\n   *\n   * @template T - The type of the response from the request.\n   * @param {Observable<T>} request - The request to be executed.\n   * @param {Observable<any>} eventForLoadingOverlay - The event that triggers the closing of the loading overlay.\n   * @returns {Observable<T>} - An observable that emits the response of the request.\n   */\n  protected executeRequestWithLoadingOverlayAndEvent<T>(request: Observable<T>, eventForLoadingOverlay: Observable<any>): Observable<T> {\n    this.openLoadingOverlay();\n\n    return this.executeRequest(request).pipe(\n      tap(() => this.closeOverlay()),\n      finalize(() => {\n        const closeOverlaySubscription = eventForLoadingOverlay.subscribe({\n          next: () => this.closeOverlay(),\n          error: () => this.closeOverlay(),\n          complete: () => this.closeOverlay(),\n        });\n        // Unsubscribe from the event when the request is finalized.\n        closeOverlaySubscription.unsubscribe();\n      }),\n      catchError((error) => {\n        this.closeOverlay();\n        throw error;\n      }),\n    );\n  }\n\n  /**\n   * Opens the loading overlay and increases the counter.\n   * The overlay will only be created on the first call.\n   */\n  private openLoadingOverlay(): void {\n    if (this.overlayRef) {\n      return;\n    }\n    const positionStrategy = this.overlay.position().global().centerHorizontally().centerVertically();\n    const overlayConfig = new OverlayConfig({\n      hasBackdrop: true,\n      backdropClass: 'cdk-overlay-dark-backdrop',\n      scrollStrategy: this.overlay.scrollStrategies.block(),\n      positionStrategy,\n    });\n    this.overlayRef = this.overlay.create(overlayConfig);\n    const spinnerPortal = new ComponentPortal(MatProgressSpinner);\n    const spinnerRef: ComponentRef<MatProgressSpinner> = this.overlayRef.attach(spinnerPortal);\n\n    spinnerRef.instance.diameter = 40;\n    spinnerRef.instance.color = 'primary';\n    spinnerRef.instance.mode = 'indeterminate';\n  }\n\n  /**\n   * Closes the overlay when the counter reaches zero.\n   * Decreases the counter and only closes the overlay when no more open calls are pending.\n   */\n  private closeOverlay(): void {\n    if (this.overlayRef) {\n      this.overlayRef.detach();\n      this.overlayRef.dispose();\n      this.overlayRef = null;\n    }\n  }\n\n  /**\n   * Retrieves the contact ID from local storage.\n   *\n   * @returns {string} The contact ID if it exists in local storage.\n   * @throws Will log an error to the console if the contact ID is not found in local storage.\n   */\n  public get contactId(): string {\n    const contactId = this.storage.get(AuthorizationConstant.contactId);\n    if (!contactId) {\n      throw new Error('Contact ID not found in local storage.');\n    }\n    return contactId;\n  }\n\n  /**\n   * Sets the active item in the view context.\n   * @param item - The item to be set as active.\n   */\n  abstract setActiveItem(item: ViewDataType): void;\n\n  /**\n   * Retrieves the active item from the view context.\n   * @param filter - Optional filter to apply when retrieving the active item.\n   * @returns The active item that matches the filter, if provided.\n   */\n  abstract getActiveItem(filter?: ViewDataType): ViewDataType;\n\n  /**\n   * Retrieves view data from the view context.\n   * @param filter - Optional filter to apply when retrieving the view data.\n   * @returns The view data that matches the filter, if provided, or an array of view data.\n   */\n  abstract getViewData(filter?: ViewDataType): ViewDataType | ViewDataType[];\n}\n","import { InjectionToken } from '@angular/core';\nimport { ViewContext } from './view.context';\n\n/**\n * The `ViewEditContext` abstract class extends the `ViewContext` class and provides\n * an interface for managing the lifecycle of an item within a view. It includes\n * methods for saving, removing, and canceling updates or creations of items.\n *\n * @abstract\n * @extends {ViewContext}\n */\nexport abstract class ViewEditContext extends ViewContext {\n  /**\n   * Saves the current item in\n   */\n  abstract save(): void;\n\n  /**\n   * Removes the current item from the view.\n   */\n  abstract remove(): void;\n\n  /**\n   * Cancels the current operation.\n   */\n  abstract cancel(): void;\n}\nexport const VIEW_EDIT_CONTEXT = new InjectionToken<ViewEditContext>('VIEW_EDIT_CONTEXT');\n","import { InjectionToken } from '@angular/core';\nimport { ViewContext } from './view.context';\nimport { ViewDataType } from './view.type';\n\n/**\n * An abstract class that provides a context for managing a list of view items.\n * Extends the `ViewContext` class.\n *\n * @abstract\n * @extends {ViewContext}\n */\nexport abstract class ViewListContext extends ViewContext {\n  /**\n   * Gets the size of the view list.\n   *\n   * @returns The number of items in the view list.\n   */\n  abstract getSize(): number;\n\n  /**\n   * Sets the items in the view list.\n   *\n   * @param items - An array of items to be set in the view list.\n   */\n  abstract setItems(items: ViewDataType[]): void;\n\n  /**\n   * Gets the items in the view list.\n   *\n   * @returns An array of items in the view list.\n   */\n  abstract getItems(): ViewDataType[];\n}\nexport const VIEW_LIST_CONTEXT = new InjectionToken<ViewListContext>('VIEW_LIST_CONTEXT');\n","import { InjectionToken, Type } from '@angular/core';\nimport { ViewRenderRegistry } from './view.render.registry';\nimport { ViewData } from './view.type';\n\nexport interface ViewRefMapperRegistry {\n  getViewTypesMap(): Map<string, Type<ViewRenderRegistry>>;\n  // getActiveView(): string;\n  // getActiveViewData(): ViewData;\n  // setActiveView(activeView: string, data?: ViewData): void;\n  // setActiveViewData(activeView: string, activeViewData?: ViewData): void;\n  setViewType(viewName: string, viewType: Type<ViewRenderRegistry>): void;\n  getViewType(viewName: string): Type<ViewRenderRegistry> | null;\n  getViewName(type: Type<ViewRenderRegistry>): string | undefined;\n}\n\nexport const VIEW_REF_MAPPER_REGISTRY = new InjectionToken<ViewRefMapperRegistry>('VIEW_REF_MAPPER_REGISTRY');\n","/*\n * Public API Surface of base\n */\nexport * from './lib/view.active';\nexport * from './lib/view.active.registry';\nexport * from './lib/view.aggregation.context';\nexport * from './lib/view.base';\nexport * from './lib/view.command';\nexport * from './lib/view.command.base';\nexport * from './lib/view.command.helper';\nexport * from './lib/view.command.mediator';\nexport * from './lib/view.command.registry';\nexport * from './lib/view.context';\nexport * from './lib/view.edit.context';\nexport * from './lib/view.list.context';\nexport * from './lib/view.options';\nexport * from './lib/view.ref.mapper.registry';\nexport * from './lib/view.render.registry';\nexport * from './lib/view.type';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}