import { effect, inject, signal } from '@angular/core';
import { ViewCommandMediator } from './view.command.mediator';
import { VIEW_COMMAND_MAPPER_REGISTRY, VIEW_COMMAND_REGISTRY } from './view.command.registry';
/**
 * Native key (shortcut) as command register.
 * It must be used in runInInjectionContext
 * @param key - shortcut key (e.g. 'ctrl+shift+1')
 * @param viewCommand - command to be executed
 * @param isShortcutRegister - is it a shortcut register
 * @param isPermanent - is it a permanent register
 */
export function nativeCommandRegister(key, viewCommand, isShortcutRegister = false, isPermanent = false) {
    const _viewCommandMediator = inject(ViewCommandMediator);
    const _viewCommandMapperRegistry = inject(VIEW_COMMAND_MAPPER_REGISTRY);
    const _viewCommandRegistry = inject(VIEW_COMMAND_REGISTRY);
    _viewCommandMediator.setViewCommandToMap(_viewCommandMapperRegistry.getKeyViewCommand(key), _viewCommandRegistry.viewName(), viewCommand, isShortcutRegister, isPermanent);
}
/**
 * Native key (shortcut) as command register.
 * With permanent
 * @param key
 * @param viewCommand
 */
export function nativeCommandWithPermanentRegister(key, viewCommand) {
    nativeCommandRegister(key, viewCommand, false, true);
}
/**
 * Native key (shortcut) as command register.
 * Without permanent
 * @param key
 * @param viewCommand
 */
export function nativeCommandWithoutPermanentRegister(key, viewCommand) {
    nativeCommandRegister(key, viewCommand, false, false);
}
/**
 * Execute commands from everywhere.
 * @warning It must be used in runInInjectionContext
 * @see {@link https://angular.dev/api/core/runInInjectionContext?tab=api}
 * @param key - shortcut key (e.g. 'ctrl+shift+1')
 * @param data - view data {@link ViewData}
 * @param viewName - view name (e.g. 'hub_component')
 */
export function executeShortcutCommand(key, data, viewName) {
    const _viewCommandMediator = inject(ViewCommandMediator);
    _viewCommandMediator.executeCommandFromMap(key, data, viewName);
}
/**
 * Creates a debounced signal that updates its value after a specified delay.
 *
 * @template T - The type of the signal value.
 * @param {Signal<T>} sourceSignal - The reference to the original signal.
 * @param {number} [debounceTimeInMs=0] - The delay in milliseconds before the signal updates.
 * @returns {Signal<T>} - A new signal that updates its value after the specified delay.
 */
export function debouncedSignal(sourceSignal, debounceTimeInMs = 0) {
    const debounceSignal = signal(sourceSignal());
    effect((onCleanup) => {
        const value = sourceSignal();
        const timeout = setTimeout(() => debounceSignal.set(value), debounceTimeInMs);
        // The `onCleanup` argument is a function which is called when the effect
        // runs again (and when it is destroyed).
        // By clearing the timeout here we achieve proper debouncing.
        // See https://angular.io/guide/signals#effect-cleanup-functions
        onCleanup(() => clearTimeout(timeout));
    }, { allowSignalWrites: true });
    return debounceSignal;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlldy5jb21tYW5kLmhlbHBlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3ZpZXcvYmFzZS9zcmMvbGliL3ZpZXcuY29tbWFuZC5oZWxwZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQVUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRS9ELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRzlELE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRTlGOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUscUJBQXFCLENBQUMsR0FBVyxFQUFFLFdBQXdCLEVBQUUscUJBQThCLEtBQUssRUFBRSxjQUF1QixLQUFLO0lBQzVJLE1BQU0sb0JBQW9CLEdBQUcsTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDekQsTUFBTSwwQkFBMEIsR0FBRyxNQUFNLENBQUMsNEJBQTRCLENBQUMsQ0FBQztJQUN4RSxNQUFNLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0lBRTNELG9CQUFvQixDQUFDLG1CQUFtQixDQUFDLDBCQUEwQixDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxFQUFFLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxFQUFFLFdBQVcsRUFBRSxrQkFBa0IsRUFBRSxXQUFXLENBQUMsQ0FBQztBQUM3SyxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsa0NBQWtDLENBQUMsR0FBVyxFQUFFLFdBQXdCO0lBQ3RGLHFCQUFxQixDQUFDLEdBQUcsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3ZELENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxxQ0FBcUMsQ0FBQyxHQUFXLEVBQUUsV0FBd0I7SUFDekYscUJBQXFCLENBQUMsR0FBRyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsc0JBQXNCLENBQUMsR0FBVyxFQUFFLElBQWUsRUFBRSxRQUFpQjtJQUNwRixNQUFNLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBRXpELG9CQUFvQixDQUFDLHFCQUFxQixDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDbEUsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsZUFBZSxDQUFJLFlBQXVCLEVBQUUsbUJBQTJCLENBQUM7SUFDdEYsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7SUFDOUMsTUFBTSxDQUNKLENBQUMsU0FBUyxFQUFFLEVBQUU7UUFDWixNQUFNLEtBQUssR0FBRyxZQUFZLEVBQUUsQ0FBQztRQUM3QixNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBRTlFLHlFQUF5RTtRQUN6RSx5Q0FBeUM7UUFDekMsNkRBQTZEO1FBQzdELGdFQUFnRTtRQUNoRSxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDekMsQ0FBQyxFQUNELEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLENBQzVCLENBQUM7SUFDRixPQUFPLGNBQWMsQ0FBQztBQUN4QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZWZmZWN0LCBpbmplY3QsIFNpZ25hbCwgc2lnbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBWaWV3Q29tbWFuZCB9IGZyb20gJy4vdmlldy5jb21tYW5kJztcbmltcG9ydCB7IFZpZXdDb21tYW5kTWVkaWF0b3IgfSBmcm9tICcuL3ZpZXcuY29tbWFuZC5tZWRpYXRvcic7XG5cbmltcG9ydCB7IFZpZXdEYXRhIH0gZnJvbSAnLi92aWV3LnR5cGUnO1xuaW1wb3J0IHsgVklFV19DT01NQU5EX01BUFBFUl9SRUdJU1RSWSwgVklFV19DT01NQU5EX1JFR0lTVFJZIH0gZnJvbSAnLi92aWV3LmNvbW1hbmQucmVnaXN0cnknO1xuXG4vKipcbiAqIE5hdGl2ZSBrZXkgKHNob3J0Y3V0KSBhcyBjb21tYW5kIHJlZ2lzdGVyLlxuICogSXQgbXVzdCBiZSB1c2VkIGluIHJ1bkluSW5qZWN0aW9uQ29udGV4dFxuICogQHBhcmFtIGtleSAtIHNob3J0Y3V0IGtleSAoZS5nLiAnY3RybCtzaGlmdCsxJylcbiAqIEBwYXJhbSB2aWV3Q29tbWFuZCAtIGNvbW1hbmQgdG8gYmUgZXhlY3V0ZWRcbiAqIEBwYXJhbSBpc1Nob3J0Y3V0UmVnaXN0ZXIgLSBpcyBpdCBhIHNob3J0Y3V0IHJlZ2lzdGVyXG4gKiBAcGFyYW0gaXNQZXJtYW5lbnQgLSBpcyBpdCBhIHBlcm1hbmVudCByZWdpc3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gbmF0aXZlQ29tbWFuZFJlZ2lzdGVyKGtleTogc3RyaW5nLCB2aWV3Q29tbWFuZDogVmlld0NvbW1hbmQsIGlzU2hvcnRjdXRSZWdpc3RlcjogYm9vbGVhbiA9IGZhbHNlLCBpc1Blcm1hbmVudDogYm9vbGVhbiA9IGZhbHNlKSB7XG4gIGNvbnN0IF92aWV3Q29tbWFuZE1lZGlhdG9yID0gaW5qZWN0KFZpZXdDb21tYW5kTWVkaWF0b3IpO1xuICBjb25zdCBfdmlld0NvbW1hbmRNYXBwZXJSZWdpc3RyeSA9IGluamVjdChWSUVXX0NPTU1BTkRfTUFQUEVSX1JFR0lTVFJZKTtcbiAgY29uc3QgX3ZpZXdDb21tYW5kUmVnaXN0cnkgPSBpbmplY3QoVklFV19DT01NQU5EX1JFR0lTVFJZKTtcblxuICBfdmlld0NvbW1hbmRNZWRpYXRvci5zZXRWaWV3Q29tbWFuZFRvTWFwKF92aWV3Q29tbWFuZE1hcHBlclJlZ2lzdHJ5LmdldEtleVZpZXdDb21tYW5kKGtleSksIF92aWV3Q29tbWFuZFJlZ2lzdHJ5LnZpZXdOYW1lKCksIHZpZXdDb21tYW5kLCBpc1Nob3J0Y3V0UmVnaXN0ZXIsIGlzUGVybWFuZW50KTtcbn1cblxuLyoqXG4gKiBOYXRpdmUga2V5IChzaG9ydGN1dCkgYXMgY29tbWFuZCByZWdpc3Rlci5cbiAqIFdpdGggcGVybWFuZW50XG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gdmlld0NvbW1hbmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hdGl2ZUNvbW1hbmRXaXRoUGVybWFuZW50UmVnaXN0ZXIoa2V5OiBzdHJpbmcsIHZpZXdDb21tYW5kOiBWaWV3Q29tbWFuZCkge1xuICBuYXRpdmVDb21tYW5kUmVnaXN0ZXIoa2V5LCB2aWV3Q29tbWFuZCwgZmFsc2UsIHRydWUpO1xufVxuXG4vKipcbiAqIE5hdGl2ZSBrZXkgKHNob3J0Y3V0KSBhcyBjb21tYW5kIHJlZ2lzdGVyLlxuICogV2l0aG91dCBwZXJtYW5lbnRcbiAqIEBwYXJhbSBrZXlcbiAqIEBwYXJhbSB2aWV3Q29tbWFuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmF0aXZlQ29tbWFuZFdpdGhvdXRQZXJtYW5lbnRSZWdpc3RlcihrZXk6IHN0cmluZywgdmlld0NvbW1hbmQ6IFZpZXdDb21tYW5kKSB7XG4gIG5hdGl2ZUNvbW1hbmRSZWdpc3RlcihrZXksIHZpZXdDb21tYW5kLCBmYWxzZSwgZmFsc2UpO1xufVxuXG4vKipcbiAqIEV4ZWN1dGUgY29tbWFuZHMgZnJvbSBldmVyeXdoZXJlLlxuICogQHdhcm5pbmcgSXQgbXVzdCBiZSB1c2VkIGluIHJ1bkluSW5qZWN0aW9uQ29udGV4dFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hbmd1bGFyLmRldi9hcGkvY29yZS9ydW5JbkluamVjdGlvbkNvbnRleHQ/dGFiPWFwaX1cbiAqIEBwYXJhbSBrZXkgLSBzaG9ydGN1dCBrZXkgKGUuZy4gJ2N0cmwrc2hpZnQrMScpXG4gKiBAcGFyYW0gZGF0YSAtIHZpZXcgZGF0YSB7QGxpbmsgVmlld0RhdGF9XG4gKiBAcGFyYW0gdmlld05hbWUgLSB2aWV3IG5hbWUgKGUuZy4gJ2h1Yl9jb21wb25lbnQnKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZVNob3J0Y3V0Q29tbWFuZChrZXk6IHN0cmluZywgZGF0YT86IFZpZXdEYXRhLCB2aWV3TmFtZT86IHN0cmluZykge1xuICBjb25zdCBfdmlld0NvbW1hbmRNZWRpYXRvciA9IGluamVjdChWaWV3Q29tbWFuZE1lZGlhdG9yKTtcblxuICBfdmlld0NvbW1hbmRNZWRpYXRvci5leGVjdXRlQ29tbWFuZEZyb21NYXAoa2V5LCBkYXRhLCB2aWV3TmFtZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBzaWduYWwgdGhhdCB1cGRhdGVzIGl0cyB2YWx1ZSBhZnRlciBhIHNwZWNpZmllZCBkZWxheS5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIHRoZSBzaWduYWwgdmFsdWUuXG4gKiBAcGFyYW0ge1NpZ25hbDxUPn0gc291cmNlU2lnbmFsIC0gVGhlIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgc2lnbmFsLlxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWJvdW5jZVRpbWVJbk1zPTBdIC0gVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIHNpZ25hbCB1cGRhdGVzLlxuICogQHJldHVybnMge1NpZ25hbDxUPn0gLSBBIG5ldyBzaWduYWwgdGhhdCB1cGRhdGVzIGl0cyB2YWx1ZSBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2VkU2lnbmFsPFQ+KHNvdXJjZVNpZ25hbDogU2lnbmFsPFQ+LCBkZWJvdW5jZVRpbWVJbk1zOiBudW1iZXIgPSAwKTogU2lnbmFsPFQ+IHtcbiAgY29uc3QgZGVib3VuY2VTaWduYWwgPSBzaWduYWwoc291cmNlU2lnbmFsKCkpO1xuICBlZmZlY3QoXG4gICAgKG9uQ2xlYW51cCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2VTaWduYWwoKTtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGRlYm91bmNlU2lnbmFsLnNldCh2YWx1ZSksIGRlYm91bmNlVGltZUluTXMpO1xuXG4gICAgICAvLyBUaGUgYG9uQ2xlYW51cGAgYXJndW1lbnQgaXMgYSBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgZWZmZWN0XG4gICAgICAvLyBydW5zIGFnYWluIChhbmQgd2hlbiBpdCBpcyBkZXN0cm95ZWQpLlxuICAgICAgLy8gQnkgY2xlYXJpbmcgdGhlIHRpbWVvdXQgaGVyZSB3ZSBhY2hpZXZlIHByb3BlciBkZWJvdW5jaW5nLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9zaWduYWxzI2VmZmVjdC1jbGVhbnVwLWZ1bmN0aW9uc1xuICAgICAgb25DbGVhbnVwKCgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG4gICAgfSxcbiAgICB7IGFsbG93U2lnbmFsV3JpdGVzOiB0cnVlIH0sXG4gICk7XG4gIHJldHVybiBkZWJvdW5jZVNpZ25hbDtcbn1cbiJdfQ==